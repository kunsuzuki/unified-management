# 開発ルール
## 0. その他のルール
Next.jsの詳細なコーディングルールは、`docs/nextjs-rules.md`を参照してください。
今回のプロジェクトの仕様や、要件についての詳細は、`docs/unified-management-app-spec.md`を参照してください。

## 1. 基本原則

### 1.1 コード品質

- **TypeScriptを必須**とし、型定義を厳格に行う
- ESLintとPrettierを導入し、コード品質を一定に保つ
- 型エラーは常にゼロを維持する
- コメントは日本語で記述し、複雑なロジックには必ず説明を付ける

### 1.2 アーキテクチャ

- **関心の分離**を徹底し、ビジネスロジック、UI、データアクセスを明確に分ける
- コンポーネントは単一責任の原則に従い、一つの機能に集中させる
- ディレクトリ構造は機能ごとに整理し、関連するファイルをグループ化する
- 共通コンポーネントは再利用可能な形で設計する

### 1.3 拡張性

- 将来的な機能追加を見据えたインターフェース設計を行う
- ハードコーディングを避け、設定ファイルやデータ駆動の実装を心がける
- 新機能の追加が既存機能に影響しないよう、疎結合を維持する

## 2. 開発プロセス

### 2.1 タスク管理

1. **タスクの細分化**
   - 大きな機能を小さなタスクに分割する
   - 各タスクは1日以内で完了できる規模に保つ
   - タスクには明確な完了条件を設定する

2. **タスクの優先順位付け**
   - 依存関係を考慮してタスクの順序を決定する
   - コアとなる機能から実装を開始する
   - リスクの高いタスクを早期に着手する

3. **タスク実行フロー**
   - タスクの開始前に必要な情報を整理する
   - 実装中は定期的に進捗を確認する
   - タスク完了後は必ずテストを実施する

### 2.2 テスト駆動開発

1. **テストファースト**
   - 機能実装前にテストケースを作成する
   - 期待される動作を明確にしてからコーディングを始める

2. **テスト種別**
   - 単体テスト: 個々の関数やコンポーネントの動作確認
   - 統合テスト: 複数のコンポーネントの連携確認
   - E2Eテスト: ユーザーフローの検証

3. **テスト自動化**
   - CIパイプラインでテストを自動実行する
   - コードカバレッジを測定し、80%以上を目標とする

### 2.3 コードレビュー

- 自己レビューを徹底し、コミット前にコードを見直す
- 変更内容が仕様に合致しているか確認する
- パフォーマンスやセキュリティの問題がないか検証する

## 3. バージョン管理ルール

### 3.1 リポジトリ設定

1. **初期設定**
   - プロジェクト開始時にGitHubリポジトリを作成する
   - `.gitignore`ファイルを適切に設定する
   - `main`ブランチを保護し、直接プッシュを禁止する

2. **ブランチ戦略**
   - `main`: 本番環境用の安定ブランチ
   - `develop`: 開発用の統合ブランチ
   - `feature/*`: 機能開発用ブランチ
   - `bugfix/*`: バグ修正用ブランチ
   - `release/*`: リリース準備用ブランチ

### 3.2 コミットルール

1. **コミット粒度**
   - 1つの論理的な変更ごとにコミットする
   - 複数の機能変更を1つのコミットにまとめない
   - ファイルフォーマットの変更と機能変更は別コミットにする

2. **コミットメッセージ**
   - 日本語で記述し、内容を明確に表現する
   - 接頭辞を使用して変更の種類を示す:
     - `feat:` 新機能
     - `fix:` バグ修正
     - `docs:` ドキュメント更新
     - `style:` コードスタイル変更
     - `refactor:` リファクタリング
     - `test:` テスト関連
     - `chore:` ビルドプロセスや補助ツールの変更

3. **コミットタイミング**
   - 機能単位で動作確認後にコミットする
   - 1日の作業終了時には必ずコミットする
   - 長時間にわたる未コミット状態を避ける

### 3.3 プルリクエスト

- 機能実装完了後にプルリクエストを作成する
- プルリクエストには変更内容の詳細な説明を含める
- マージ前に必ずテストが成功していることを確認する

## 4. フロントエンド開発ルール

### 4.1 Next.js固有のルール

- App Routerを標準採用し、ページディレクトリ構造を適切に設計する
- サーバーコンポーネントとクライアントコンポーネントを適切に使い分ける
- API Routesは使用せず、Server Actionsでサーバー処理を実装する
- メタデータを適切に設定し、SEO対策を行う

### 4.2 コンポーネント設計

- Atomic Designの考え方を取り入れ、コンポーネントを階層化する
- 再利用可能なコンポーネントは`components/ui`ディレクトリに配置する
- ページ固有のコンポーネントは対応するページディレクトリ内に配置する
- コンポーネントのpropsには必ず型定義を行う

### 4.3 状態管理

- サーバーコンポーネントを最大限活用し、クライアント側の状態を最小限に抑える
- URL状態はnuqsで管理し、ブラウザ履歴と連動させる
- クライアント状態はReact Context APIで管理する
- グローバル状態は必要最小限に留め、コンポーネント内の状態を優先する

### 4.4 スタイリング

- Tailwind CSSを基本とし、一貫したデザインシステムを構築する
- shadcn/uiコンポーネントを活用し、UIの統一感を保つ
- アイコンはlucide-reactを使用する
- レスポンシブデザインを徹底し、モバイルファーストで実装する

## 5. バックエンド開発ルール

### 5.1 データベース設計

- テーブル名は単数形で統一する（例: `user`, `document`, `task`）
- 主キーには`id`を使用し、UUIDを採用する
- 外部キーには`_id`サフィックスを付ける（例: `user_id`）
- 作成日時と更新日時は全テーブルに含める
- インデックスを適切に設定し、クエリパフォーマンスを最適化する

### 5.2 API設計

- RESTfulな設計原則に従う
- エンドポイントは名詞を使用し、複数形で表現する（例: `/api/documents`）
- HTTPメソッドを適切に使い分ける（GET, POST, PUT, DELETE）
- レスポンスは一貫した形式で返す
- エラーハンドリングを徹底し、適切なステータスコードとメッセージを返す

### 5.3 認証・認可

- Supabase Authを活用し、セキュアな認証システムを構築する
- Row Level Security (RLS)を設定し、データアクセス制御を行う
- 認証情報は安全に管理し、トークンの有効期限を適切に設定する
- 権限管理を明確にし、ユーザーごとのアクセス制御を実装する

## 6. 破壊的変更の防止

### 6.1 安全対策

- **バックアップの徹底**
  - 重要な変更前には必ずデータベースのバックアップを取得する
  - コード変更前には作業ブランチを作成し、元の状態を保存する

- **段階的な変更**
  - 大規模な変更は小さな変更に分割して実装する
  - 各ステップで動作確認を行い、問題があれば即座にロールバックする

- **フィーチャーフラグ**
  - 新機能は最初はフィーチャーフラグで無効化しておき、テスト後に有効化する
  - 既存機能の変更も同様にフラグで制御し、安全に切り替えられるようにする

### 6.2 データ移行

- スキーマ変更時は必ずマイグレーションスクリプトを作成する
- データ整合性を保つため、マイグレーションは自動テストを行う
- 本番環境への適用前にステージング環境でマイグレーションをテストする

### 6.3 デプロイ戦略

- カナリアリリースやブルー/グリーンデプロイを検討し、リスクを最小化する
- デプロイ後は自動テストを実行し、基本機能が正常に動作することを確認する
- 問題発生時に即座にロールバックできる仕組みを用意する

## 7. 開発ステップ

### 7.1 プロジェクト初期化フェーズ

1. **環境構築**
   - GitHubリポジトリの作成
   - Next.jsプロジェクトの初期化
   - ESLint, Prettier, TypeScriptの設定
   - Tailwind CSS, shadcn/uiのセットアップ

2. **基本設計**
   - ディレクトリ構造の決定
   - ルーティング設計
   - コンポーネント階層の設計
   - データモデルの詳細設計

3. **インフラ構築**
   - Supabaseプロジェクトの作成
   - データベーススキーマの実装
   - 認証システムの設定
   - Cloudflare Pagesの設定

### 7.2 機能実装フェーズ

1. **認証機能**
   - サインアップ/ログインフォーム
   - 認証状態の管理
   - 保護されたルートの実装

2. **ドキュメント管理機能**
   - マークダウンエディタの実装
   - ドキュメント保存機能
   - ドキュメント一覧表示

3. **タスク管理機能**
   - タスクCRUD操作
   - カンバンビュー実装
   - カレンダービュー実装
   - 階層構造の管理

4. **メモ管理機能**
   - メモ作成インターフェース
   - メモ一覧表示
   - タグ付け機能

5. **タグ管理機能**
   - グローバルタグの作成・編集
   - コンテンツへのタグ付け
   - タグによるフィルタリング

6. **コンテンツ間紐付け機能**
   - 関連付けインターフェース
   - 関連コンテンツの表示

7. **検索機能**
   - 全文検索の実装
   - タグによる横断検索
   - 検索結果の表示

### 7.3 テスト・最適化フェーズ

1. **単体テスト**
   - コンポーネントテスト
   - ユーティリティ関数テスト
   - API関数テスト

2. **統合テスト**
   - ページ単位のテスト
   - データフローテスト

3. **E2Eテスト**
   - 主要ユーザーフローのテスト
   - エラーケースのテスト

4. **パフォーマンス最適化**
   - レンダリングパフォーマンスの改善
   - データ取得の最適化
   - バンドルサイズの最適化

5. **アクセシビリティ対応**
   - キーボード操作の確認
   - スクリーンリーダー対応
   - コントラスト比の確認

### 7.4 デプロイフェーズ

1. **ステージング環境デプロイ**
   - Cloudflare Pagesへのデプロイ
   - 動作確認とバグ修正

2. **本番環境デプロイ**
   - 最終チェック
   - 本番環境へのデプロイ
   - デプロイ後の動作確認

3. **モニタリング設定**
   - エラー監視の設定
   - パフォーマンスモニタリング
   - ユーザーフィードバック収集の仕組み構築

## 8. ユーザーレビューと開発フロー

### 8.1 ユーザーレビュープロセス

1. **レビューポイントの設定**
   - 機能単位でレビューポイントを設定する
   - 各開発フェーズの完了時に必ずレビューを実施する
   - ブラウザで確認可能な機能が実装された時点で必ず通知する

2. **レビュー通知**
   - レビュー可能な状態になったら、「レビュー可能な機能が完了しました」と明確に通知する
   - デプロイ先のURLとアクセス方法を提供する
   - テスト用アカウント情報（必要な場合）を提供する
   - 確認してほしいポイントを具体的に列挙する

3. **レビュー待機状態**
   - ユーザーレビュー中は開発を一時停止する
   - レビュー結果を待つ間、次のタスクの準備や計画の整理を行う
   - ユーザーから「次のステップに進んで」と指示があるまで開発を再開しない

4. **フィードバック反映**
   - ユーザーからのフィードバックを整理し、必要な修正点を特定する
   - 修正の優先順位を決定し、実装計画を立てる
   - 大きな変更が必要な場合は、影響範囲を評価し、安全な実装方法を検討する

### 8.2 開発再開ルール

1. **開発再開のトリガー**
   - ユーザーから「次のステップに進んで」または同等の指示があった場合のみ開発を再開する
   - 再開前にフィードバックを反映した実装計画を確認する

2. **開発再開時のプロセス**
   - フィードバックに基づく修正を優先的に実施する
   - 修正内容を明確に記録し、コミットメッセージに反映させる
   - 修正後は再度テストを行い、問題が解決したことを確認する

3. **進捗報告**
   - 修正完了時には、変更内容と対応状況を明確に報告する
   - 次の開発ステップを提案し、ユーザーの承認を得る

## 9. 継続的改善

- 定期的にコードの健全性をレビューする
- 技術的負債を計画的に返済する
- ユーザーフィードバックを収集し、優先度の高い改善を実施する
- パフォーマンスメトリクスを定期的に測定し、改善点を特定する

---

このルールセットは、Gemini CLIによる自動開発を効率化し、高品質なコードベースを維持するための指針です。プロジェクトの進行に合わせて適宜更新し、最適な開発プロセスを確立してください。
